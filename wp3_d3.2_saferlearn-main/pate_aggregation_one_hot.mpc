# coding: latin-1
"""
  Secure aggregator using Multi-Party Computation that determines the most chosen label by the teachers.

  Uses external teachers to computing parties (as of now) providing the input labels and receiving an authenticated result.
  See pate-teacher.cpp for teacher (and setup instructions).
  
  Wait for MAX_NUM_TEACHERS to join the game or teacher finish flag to be sent
  before calculating the maximum.

  Note each teacher connects in a single thread and so is potentially blocked.
  
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue, cint
from Compiler.instructions import listen, acceptclientconnection, crash
from Compiler.library import print_ln, print_ln_if, do_while, for_range, if_
from Compiler.util import if_else

import argparse

parser = argparse.ArgumentParser()
parser.add_argument("progname")
parser.add_argument("--batch-size", help="Determine the size of batchs, i.e the number of votes sent by teachers for each round.", type=int, default=10)
parser.add_argument("--max-num-teachers", help="Determine the max number of teachers. Setting a large number may impact the performances.", type=int, default=10)
parser.add_argument("--num-labels", help="Determine the number of labels.", type=int, default=10)
parser.add_argument("--rounds", help="Determine the number of rounds", type=int, default=0)
parser.add_argument("--port", help="Secify the port used as base", type=int, default=14000)
parser.add_argument("-M", "--preserve-mem-order", action='store_true')
parser.add_argument("-D", "--dead-code-elimination", action='store_true')
parser.add_argument("-v", "--verbose", action='store_true')
args = parser.parse_args()


PORTNUM = args.port
BATCH_SIZE = args.batch_size
MAX_NUM_TEACHERS = args.max_num_teachers
NUM_LABELS = args.num_labels
N_ROUNDS = args.rounds

def accept_teacher():
    """
    Accept a socket connection returning the id of the teacher and the value of the last-flag.
    """
    teacher_socket_id = regint()
    acceptclientconnection(teacher_socket_id, PORTNUM)
    last_flag = regint.read_from_socket(teacher_socket_id)
    return teacher_socket_id, last_flag

def teacher_input(teacher_socket_id):
    """
    Send share of random value, receive input and deduce share.
    """
    teacher_inputs = Array.create_from(sint.receive_from_client(BATCH_SIZE * NUM_LABELS, teacher_socket_id))

    return teacher_inputs


def determine_winner(number_teachers, teachers_votes):
    """Return an Array of vote values corresponding to the votes the most popular."""

    winning_label = Array(BATCH_SIZE, sint)
    winning_label.assign_all(sint(-1))
    
    
    aggregate = sint.Matrix(BATCH_SIZE, NUM_LABELS)
    aggregate.assign_all(sint(0))
    
    @for_range(BATCH_SIZE)
    def loop_vote(vote):
        @for_range(NUM_LABELS)
        def loop_teacher(label):
            @for_range(MAX_NUM_TEACHERS)
            def loop_teacher(teacher):
                aggregate[vote][label] += teachers_votes[teacher][vote][label]
                return teacher < number_teachers - 1

    max_nb_votes = Array(1, sint)
    @for_range(BATCH_SIZE)
    def loop_vote(vote):
        max_nb_votes[0] = aggregate[vote][0]
        winning_label[vote] = sint(0)
        @for_range(1, NUM_LABELS)
        def loop_teacher(label):
            # Check if new max
            new_max = aggregate[vote][label].greater_than(max_nb_votes[0])
            # Securely choose between two values according to a secret value
            max_nb_votes[0] = if_else(new_max, aggregate[vote][label], max_nb_votes[0])
            winning_label[vote] = if_else(new_max, sint(label), winning_label[vote])
    return winning_label


def write_label_to_teachers(sockets, number_teachers, correct_label):
    """Send share of winning label to all teachers who joined game."""
    # To be changed to send to the student

    authenticated_data = Array(3*BATCH_SIZE, sint)
    @for_range(BATCH_SIZE)
    def loop_labels(label):
        authenticated_data[3*label] = correct_label[label]
        authenticated_data[3*label + 1] = sint.get_random_triple()[0]
        authenticated_data[3* label + 2] = correct_label[label] * authenticated_data[3*label + 1]

    @for_range(MAX_NUM_TEACHERS)
    def loop_body(teacher):
        sint.write_shares_to_socket(sockets[teacher], authenticated_data.get_vector())
        return teacher < number_teachers - 1


def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run comparison and return result."""
    # Start listening for teacher socket connections
    listen(PORTNUM)
    print_ln('Listening for teacher connections on base port %s', PORTNUM)

    # Array with the number of 'correct' votes for each of the teacher
    total_number_of_correct_votes = Array(MAX_NUM_TEACHERS,sint)
    total_number_of_correct_votes.assign_all(sint(0))

    number_of_votes = Array(1, cint)
    number_of_votes[0] = 0
   
    # Fraud detection
    # 1 -> the teacher seems honest
    # 0 -> the teacher makes too many errors compared to other models
    fraud_detection = Array(MAX_NUM_TEACHERS, sint)
    fraud_detection.assign_all(sint(1))
    # less than 70% of correct responses is suspect 
    fraud_threshold = cint(7)
    
    def game_loop(_=None):
        print_ln('Starting a new round of aggregation.')
        # Teachers socket id (integer).
        teacher_sockets = Array(MAX_NUM_TEACHERS, regint)
        # Number of teachers
        number_teachers = MemValue(regint(0))
                # Input size 1-hot / batch / teachers
        # Number labels * Batch size * max num teachers
        input_size = [MAX_NUM_TEACHERS, BATCH_SIZE, NUM_LABELS]
        # Teachers secret input.
        teachers_votes = MultiArray(input_size, sint)
        # Keep track of received inputs
        seen = Array(MAX_NUM_TEACHERS, regint)
        seen.assign_all(0)


        # Loop round waiting for each teacher to connect
        @for_range(MAX_NUM_TEACHERS)
        def teacher_connections(_):
            teacher_id, last_flag = accept_teacher()
            @if_(teacher_id >= MAX_NUM_TEACHERS)
            def _():
                print_ln("Teacher's id too high")
                crash()
            teacher_sockets[teacher_id] = teacher_id # this line seem useless
            seen[teacher_id] = 1
            @if_(last_flag == 1)
            def _():
                number_teachers.write(teacher_id + 1)

            # Retreiving each teacher's input
            inputs = teacher_input(teacher_id)
            @for_range(BATCH_SIZE)
            def loop_vote(vote_index):
                @for_range(NUM_LABELS)
                def loop_label(label):
                    teachers_votes[teacher_id][vote_index][label] = inputs[vote_index * NUM_LABELS + label]

        number_of_votes[0] += BATCH_SIZE
            
        winning_label = determine_winner(number_teachers, teachers_votes)
        write_label_to_teachers(teacher_sockets, number_teachers, winning_label)
        
        correct_vote = Array(1, sint)
        
      	# updating the total_number_of_correct_votes table, if a vote was correct +1 for the teacher
        @for_range(MAX_NUM_TEACHERS)
        def loop_body(teacher):
            # TO CHANGE
            @for_range(BATCH_SIZE)
            def loop_body(vote):
                correct_vote[0] = 1
                @for_range(NUM_LABELS)
                def loop_teacher(label):
                    expected_value = if_else(sint(label) == winning_label[vote], sint(1), sint(0))
                    total_number_of_correct_votes[teacher] += (expected_value == teachers_votes[teacher][vote][label])
            fraud_detection[teacher] = total_number_of_correct_votes[teacher].greater_equal((fraud_threshold * number_of_votes[0]) / 10)
            # Right now, we can't do much since we only have the id to ientify teachers and with our protocol, they are easily forgeable
            print_ln_if(fraud_detection[teacher].equal(0).reveal(), 'Fraud detection: %s with %s less than threshold %s', teacher, total_number_of_correct_votes[teacher].reveal(), (fraud_threshold * number_of_votes[0]) / 10)
            return teacher < number_teachers - 1

        return True

    if N_ROUNDS > 0:
        print('run %d rounds' % N_ROUNDS)
        for_range(N_ROUNDS)(game_loop)
        

    else:
        print('run forever')
        do_while(game_loop)

main()